<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue技术内幕 | 其他重要选项的初始化及实现</title>
    <meta name="description" content="逐行级别的 Vue 源码分析">
    
    
    <link rel="preload" href="/vue-design/assets/css/0.styles.54bd1fd1.css" as="style"><link rel="preload" href="/vue-design/assets/js/app.6d653ceb.js" as="script"><link rel="preload" href="/vue-design/assets/js/5.cae9faa7.js" as="script"><link rel="prefetch" href="/vue-design/assets/js/15.95b335e9.js"><link rel="prefetch" href="/vue-design/assets/js/1.c0f36928.js"><link rel="prefetch" href="/vue-design/assets/js/2.243eafc6.js"><link rel="prefetch" href="/vue-design/assets/js/3.dca87133.js"><link rel="prefetch" href="/vue-design/assets/js/4.1aa8eae8.js"><link rel="prefetch" href="/vue-design/assets/js/6.7e2440cb.js"><link rel="prefetch" href="/vue-design/assets/js/7.309b3f1b.js"><link rel="prefetch" href="/vue-design/assets/js/8.7b9253b0.js"><link rel="prefetch" href="/vue-design/assets/js/9.833128f6.js"><link rel="prefetch" href="/vue-design/assets/js/10.ac16dcdd.js"><link rel="prefetch" href="/vue-design/assets/js/11.72841bcb.js"><link rel="prefetch" href="/vue-design/assets/js/12.ee5508ab.js"><link rel="prefetch" href="/vue-design/assets/js/13.76623aa8.js"><link rel="prefetch" href="/vue-design/assets/js/14.b8110d7d.js"><link rel="prefetch" href="/vue-design/assets/js/16.1ba9e9af.js"><link rel="prefetch" href="/vue-design/assets/js/17.9e9bf45f.js"><link rel="prefetch" href="/vue-design/assets/js/18.34bd5537.js"><link rel="prefetch" href="/vue-design/assets/js/19.037189b9.js"><link rel="prefetch" href="/vue-design/assets/js/20.6dae14aa.js"><link rel="prefetch" href="/vue-design/assets/js/21.08b2ed9f.js"><link rel="prefetch" href="/vue-design/assets/js/22.ea05ebc0.js"><link rel="prefetch" href="/vue-design/assets/js/23.32caa073.js"><link rel="prefetch" href="/vue-design/assets/js/24.da29a388.js"><link rel="prefetch" href="/vue-design/assets/js/25.09cf99ce.js"><link rel="prefetch" href="/vue-design/assets/js/26.677190c7.js"><link rel="prefetch" href="/vue-design/assets/js/27.b5e6082d.js"><link rel="prefetch" href="/vue-design/assets/js/28.48fbdee8.js"><link rel="prefetch" href="/vue-design/assets/js/29.7dc22095.js"><link rel="prefetch" href="/vue-design/assets/js/30.70f67c8f.js"><link rel="prefetch" href="/vue-design/assets/js/31.5c4e6863.js">
    <link rel="stylesheet" href="/vue-design/assets/css/0.styles.54bd1fd1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/vue-design/" class="home-link router-link-active"><!----><span class="site-name">
      Vue技术内幕
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/vue-design/art/" class="nav-link router-link-active">正文</a></div><div class="nav-item"><a href="/vue-design/appendix/" class="nav-link">附录</a></div><div class="nav-item"><a href="/vue-design/more/" class="nav-link">扩展阅读</a></div><div class="nav-item"><a href="/vue-design/donate/" class="nav-link">人之初</a></div><div class="nav-item"><a href="/vue-design/about/" class="nav-link">关于</a></div><a href="https://github.com/HcySunYang/vue-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue-design/art/" class="nav-link router-link-active">正文</a></div><div class="nav-item"><a href="/vue-design/appendix/" class="nav-link">附录</a></div><div class="nav-item"><a href="/vue-design/more/" class="nav-link">扩展阅读</a></div><div class="nav-item"><a href="/vue-design/donate/" class="nav-link">人之初</a></div><div class="nav-item"><a href="/vue-design/about/" class="nav-link">关于</a></div><a href="https://github.com/HcySunYang/vue-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>正文(持续更新...)</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/vue-design/art/" class="sidebar-link">前言</a></li><li><a href="/vue-design/art/1start-learn.html" class="sidebar-link">了解 Vue 这个项目</a></li><li><a href="/vue-design/art/2vue-constructor.html" class="sidebar-link">Vue 构造函数</a></li><li><a href="/vue-design/art/3vue-example.html" class="sidebar-link">以一个例子为线索</a></li><li><a href="/vue-design/art/4vue-normalize.html" class="sidebar-link">Vue 选项的规范化</a></li><li><a href="/vue-design/art/5vue-merge.html" class="sidebar-link">Vue 选项的合并</a></li><li><a href="/vue-design/art/6vue-init-start.html" class="sidebar-link">Vue 的初始化之开篇</a></li><li><a href="/vue-design/art/7vue-reactive.html" class="sidebar-link">揭开数据响应系统的面纱</a></li><li><a href="/vue-design/art/8vue-reactive-dep-watch.html" class="sidebar-link">渲染函数的观察者与进阶的数据响应系统</a></li><li><a href="/vue-design/art/9vue-state-init.html" class="active sidebar-link">其他重要选项的初始化及实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-design/art/9vue-state-init.html#props-的初始化及实现" class="sidebar-link">props 的初始化及实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-design/art/9vue-state-init.html#props-的初始化" class="sidebar-link">props 的初始化</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/9vue-state-init.html#props-的校验" class="sidebar-link">props 的校验</a></li></ul></li><li class="sidebar-sub-header"><a href="/vue-design/art/9vue-state-init.html#methods-选项的初始化及实现" class="sidebar-link">methods 选项的初始化及实现</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/9vue-state-init.html#provide-选项的初始化及实现" class="sidebar-link">provide 选项的初始化及实现</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/9vue-state-init.html#inject-选项的初始化及实现" class="sidebar-link">inject 选项的初始化及实现</a></li></ul></li><li><a href="/vue-design/art/80vue-compiler-start.html" class="sidebar-link">Vue 的编译器初探</a></li><li><a href="/vue-design/art/81vue-parse-ast.html" class="sidebar-link">词法分析 - 为生成AST做准备</a></li><li><a href="/vue-design/art/82vue-parsing.html" class="sidebar-link">Vue 句法分析 - 生成真正的AST</a></li><li><a href="/vue-design/art/83vue-codegen.html" class="sidebar-link">编译器之代码的生成</a></li><li><a href="/vue-design/art/84vue-vdom.html" class="sidebar-link">虚拟DOM解析</a></li><li><a href="/vue-design/art/85vue-vdom-patch.html" class="sidebar-link">虚拟DOM补丁算法详解</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="其他重要选项的初始化及实现"><a href="#其他重要选项的初始化及实现" aria-hidden="true" class="header-anchor">#</a> 其他重要选项的初始化及实现</h1><p>在前面的章节中，我们以 <code>initState</code> 函数为切入点讲解了数据响应系统，又通过数据响应系统讲解了 <code>watch</code> 和计算属性的实现，现在我们重新审视一下 <code>initState</code> 函数，如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initState</span> <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>如上高亮的代码所示，到目前为止整个 <code>initState</code> 函数中我们还剩下 <code>props</code> 以及 <code>method</code> 等选项的初始化和实现没有讲，接下来的内容我们将继续探索剩余选项的初始化及实现。</p><h2 id="props-的初始化及实现"><a href="#props-的初始化及实现" aria-hidden="true" class="header-anchor">#</a> props 的初始化及实现</h2><h3 id="props-的初始化"><a href="#props-的初始化" aria-hidden="true" class="header-anchor">#</a> props 的初始化</h3><p>首先我们要讲的是 <code>props</code> 选项的初始化及实现，在 <code>initState</code> 函数中可以看到如下这句代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
</code></pre><p>可以发现，只有当 <code>opts.props</code> 选项存在时才会调用 <code>initProps</code> 函数进行初始化工作。<code>initProps</code> 函数与其他选项的初始化函数类似，接收两个参数分别是组件实例对象 <code>vm</code> 和选项 <code>opts.props</code>。</p><p>在讲解 <code>initProps</code> 函数的具体实现之前，我们需要回顾一下 <code>opts.props</code> 的数据结构是什么样子的，在 <a href="/vue-design/art/4vue-normalize.html">Vue 选项的规范化</a> 一节中我们了解到 <code>props</code> 选项是经过规范化处理的，并且规范后的数据是纯对象格式，假如我们像如下代码这样使用 <code>props</code> 选项：</p><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;someData&quot;</span><span class="token punctuation">]</span>
</code></pre><p>那么最终 <code>props</code> 选项将会被规范化为：</p><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  someData<span class="token punctuation">:</span><span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>如果我们像如下代码这样使用 <code>props</code> 选项：</p><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  someData1<span class="token punctuation">:</span> Number
<span class="token punctuation">}</span>
</code></pre><p>那么 <code>props</code> 选项将被规范化为：</p><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  someData1<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> Number
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>总之在被规范化后的 <code>props</code> 选项将会是一个对象，并且该对象每个属性的键名就是对应 <code>prop</code> 的名字，而且每个属性的值都是一个至少会包含一个 <code>type</code> 属性的对象。</p><p>明白了这些我们就可以开始研究 <code>initProps</code> 函数了，找到 <code>initProps</code> 函数，该函数的开头定义了四个常量：</p><pre class="language-js"><code><span class="token keyword">const</span> propsData <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>_props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// cache prop keys so that future props updates can iterate using Array</span>
<span class="token comment">// instead of dynamic object key enumeration.</span>
<span class="token keyword">const</span> keys <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_propKeys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> isRoot <span class="token operator">=</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>$parent
</code></pre><p>首先定义了 <code>propsData</code> 常量，如果 <code>vm.$options.propsData</code> 存在，则使用 <code>vm.$options.propsData</code> 的值作为 <code>propsData</code> 常量的值，否则 <code>propsData</code> 常量的值为空对象。</p><p>那么 <code>vm.$options.propsData</code> 是什么呢？顾名思义 <code>propsData</code> 就是 <code>props</code> 数据，我们知道组件的 <code>props</code> 代表接收来自外界传递进来的数据，这些数据总要存在某个地方，使得我们在组件内使用，而 <code>vm.$options.propsData</code> 就是用来存储来自外界的组件数据的。</p><p>举个例子，如下是使用自定义组件并向组件传递数据的例子：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">prop1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">prop2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>2<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><p>上面的代码中我们向自定义组件 <code>some-comp</code> 传递了两个属性，注意此时组件并没有把这两个属性作为 <code>props</code> 看待，但是如果自定义组件中显示声明了 <code>props</code>：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'someCopm'</span><span class="token punctuation">,</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'prop1'</span><span class="token punctuation">,</span> <span class="token string">'prop2'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>这时自定义组件 <code>some-comp</code> 才会把外界传递进来的属性作为 <code>props</code> 对待，并解析相应 <code>props</code> 数据。如何解析呢？拿上面的例子来说，会从如下模板中：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">prop1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">prop2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>2<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><p>解析出两个 <code>props</code> 的键值对，并生成一个对象：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  prop1<span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>
  prop2<span class="token punctuation">:</span> <span class="token string">'2'</span>
<span class="token punctuation">}</span>
</code></pre><p>实际上这个对象就是 <code>vm.$options.propsData</code> 的值：</p><pre class="language-js"><code>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData <span class="token operator">=</span> <span class="token punctuation">{</span>
  prop1<span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>
  prop2<span class="token punctuation">:</span> <span class="token string">'2'</span>
<span class="token punctuation">}</span>
</code></pre><p>以上说明只是为了让大家明白 <code>propsData</code> 的作用和来历，有很多不严谨的地方，但足够让大家理解。更具体的内容我们会在编译器和子组件的创建相关章节中为大家详细说明。</p><p>这样我们就明白了第一个常量 <code>propsData</code> 的作用，它存储着外界传递进来的 <code>props</code> 的值。接着我们看一下第二个常量：</p><pre class="language-js"><code><span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>_props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><p>定义了 <code>props</code> 常量和 <code>vm._props</code> 属性，它和 <code>vm._props</code> 属性具有相同的引用并且初始值为空对象：<code>{}</code>。</p><p>再来看第三个常量：</p><pre class="language-js"><code><span class="token keyword">const</span> keys <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_propKeys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre><p>定义了常量 <code>keys</code>，同时在 <code>vm.options</code> 上添加 <code>_propKeys</code> 属性，并且常量 <code>keys</code> 与 <code>vm.$options._propKeys</code> 属性具有相同的引用，且初始值是一个空数组：<code>[]</code>。</p><p>最后一个常量为 <code>isRoot</code>：</p><pre class="language-js"><code><span class="token keyword">const</span> isRoot <span class="token operator">=</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>$parent
</code></pre><p><code>isRoot</code> 常量用来标识是否是根组件，因为根组件实例的 <code>$parent</code> 属性的值是不存在的，所以当 <code>vm.$parent</code> 为假时说明当前组件实例时根组件。</p><p>在这些常量的下面，是如下这段代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> propsOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
<span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre><p>这段代码的重点在 <code>for...in</code> 循环语句块内，为了结构清晰如上代码中我们省略了 <code>for...in</code> 循环语句块内的代码。可以看到在 <code>for...in</code> 循环执行之前执行一段 <code>if</code> 条件语句块：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>只要当前组件实例不是根节点，那么该 <code>if</code> 语句块内的代码将会被执行，即调用 <code>toggleObserving</code> 函数并传递 <code>false</code> 作为参数。另外我们也可以发现，在 <code>for...in</code> 循环之后再次调用了 <code>toggleObserving</code> 函数，只不过这一次所传递的参数是 <code>true</code>。我们前面遇到过 <code>toggleObserving</code> 函数，我们知道这个函数的作用类似一个开关，它会修改 <code>src/core/observer/index.js</code> 文件中 <code>shouldObserve</code> 变量的值。并且我们注意到 <code>observe</code> 函数中的这段代码，如下高亮代码所示：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">observe</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> any<span class="token punctuation">,</span> asRootData<span class="token punctuation">:</span> <span class="token operator">?</span>boolean<span class="token punctuation">)</span><span class="token punctuation">:</span> Observer <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">'__ob__'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>__ob__ <span class="token keyword">instanceof</span> <span class="token class-name">Observer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ob <span class="token operator">=</span> value<span class="token punctuation">.</span>__ob__
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
<span class="highlighted-line">    shouldObserve <span class="token operator">&amp;&amp;</span></span>    <span class="token operator">!</span><span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span>value<span class="token punctuation">.</span>_isVue
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 省略...</span>
  <span class="token keyword">return</span> ob
<span class="token punctuation">}</span>
</code></pre><p>这意味着当你调用 <code>observe</code> 函数去观测一个数据对象时，只有当变量 <code>shouldObserve</code> 为真的时候才会进行观测。所以我们才说 <code>toggleObserving</code> 函数是一个开关，因为它能修改 <code>shouldObserve</code> 变量的值。</p><p>再回到如下代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="highlighted-line">  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span></span><span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> propsOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
<span class="highlighted-line"><span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span></span></code></pre><p>为什么这里在 <code>for...in</code> 循环之前“关闭开关”，在循环结束之后又“打开开关”呢？这么做肯定是有原因的，不过我们需要先弄清楚 <code>for...in</code> 循环语句块内做了什么事情才行，接下来我们开始研究这个 <code>for...in</code> 循环。</p><p>首先该 <code>for...in</code> 循环所遍历的对象是 <code>propsOptions</code>，它就是 <code>props</code> 选项参数，我们前面分析了它的格式，所以 <code>for...in</code> 循环中的 <code>key</code> 就是每个 <code>prop</code> 的名字。</p><p>在循环内的一开头是如下两句代码：</p><pre class="language-js"><code>keys<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">validateProp</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> propsOptions<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
</code></pre><p>首先将 <code>prop</code> 的名字(<code>key</code>)添加到 <code>keys</code> 数组中，我们知道常量 <code>keys</code> 与 <code>vm.$options._propKeys</code> 属性具有相同的引用，所以这等价于将 <code>key</code> 添加到 <code>vm.$options._propKeys</code> 属性中，至于为什么添加到 <code>vm.$options._propKeys</code> 属性，我们会在后面讲到。</p><p>接着定义了 <code>value</code> 常量，该常量的值为 <code>validateProp</code> 函数的返回值。一句话概括 <code>validateProp</code> 函数的作用：用来校验名字给定的 <code>prop</code> 数据是否符合预期的类型，并返回相应 <code>prop</code> 的值(或默认值)。至于 <code>validateProp</code> 函数的具体实现我们放到后面讲，现在大家只需要知道 <code>validateProp</code> 函数会返回给定名字的 <code>prop</code> 的值即可，也就是说常量 <code>value</code> 中保存着 <code>prop</code> 的值。</p><p>接着是一个 <code>if...else</code> 语句块：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hyphenatedKey <span class="token operator">=</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReservedAttribute</span><span class="token punctuation">(</span>hyphenatedKey<span class="token punctuation">)</span> <span class="token operator">||</span>
      config<span class="token punctuation">.</span><span class="token function">isReservedAttr</span><span class="token punctuation">(</span>hyphenatedKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token string">`&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hyphenatedKey<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is a reserved attribute and cannot be used as component prop.`</span></span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isUpdatingChildComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token string">`Avoid mutating a prop directly since the value will be `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`overwritten whenever the parent component re-renders. `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`Instead, use a data or computed property based on the prop's `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`value. Prop being mutated: &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;`</span></span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>在非生产环境下 <code>if</code> 语句块的代码将被执行，反之 <code>else</code> 语句块内的代码将被执行，前面我们说过，无论是生产环境还是非生产环境，应该保证行为一致才是最关键的一点。在如上代码中虽然 <code>if</code> 语句块内的代码很多，而 <code>else</code> 语句块只有一句代码，但其实他们的行为是一致的，之所以 <code>if</code> 语句块的代码会比较多，那是因为在非生产环境下要做很多打印警告信息使开发更加友好的工作。</p><p>所以如上 <code>if...else</code> 语句块最终的目的可以用一句代码来代替，即：</p><pre class="language-js"><code><span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
</code></pre><p>使用 <code>defineReactive</code> 函数将 <code>prop</code> 定义到常量 <code>props</code> 上，我们知道 <code>props</code> 常量与 <code>vm._props</code> 属性具有相同的引用，所以这等价于在 <code>vm._props</code> 上定义了 <code>prop</code> 数据。</p><p>同时大家注意 <code>defineReactive</code> 函数的调用被 <code>toggleObserving</code> 函数的调用所包围，如下：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="highlighted-line">  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span></span><span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> propsOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="highlighted-line">    <span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span></span>  <span class="token punctuation">}</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
<span class="highlighted-line"><span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span></span></code></pre><p>为了搞清楚其目的，我们需要找到 <code>defineReactive</code> 函数，注意如下高亮的代码：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">defineReactive</span> <span class="token punctuation">(</span>
  obj<span class="token punctuation">:</span> Object<span class="token punctuation">,</span>
  key<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  val<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  customSetter<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token operator">?</span>Function<span class="token punctuation">,</span>
  shallow<span class="token operator">?</span><span class="token punctuation">:</span> boolean
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>

<span class="highlighted-line">  <span class="token keyword">let</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span></span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span> <span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>如上那句高亮的代码所示，在使用 <code>defineReactive</code> 函数定义属性时，会调用 <code>observe</code> 函数对值继续进行观测。但由于之前使用了 <code>toggleObserving(false)</code> 函数关闭了开关，所以上面高亮代码中调用 <code>observe</code> 函数是一个无效调用。所以我们可以得出一个结论：<strong>在定义 <code>props</code> 数据时，不将 <code>prop</code> 值转换为响应式数据</strong>，这里要注意的是：<strong>由于 <code>props</code> 本身是通过 <code>defineReactive</code> 定义的，所以 <code>props</code> 本身是响应式的，但没有对值进行深度定义</strong>。为什么这样做呢？很简单，我们知道 <code>props</code> 是来自外界的数据，或者更具体一点的说，<code>props</code> 是来自父组件的数据，这个数据如果是一个对象(包括纯对象和数组)，那么它本身可能已经是响应式的了，所以不再需要重复定义。另外在定义 <code>props</code> 数据之后，又调用 <code>toggleObserving(true)</code> 函数将开关开启，这么做的目的是不影响后续代码的功能，因为这个开关是全局的。</p><p>最后大家还要注意一点，如下：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>这段代码说明，只有当不是根组件的时候才会关闭开关，这说明如果当前组件实例是根组件的话，那么定义的 <code>props</code> 的值也会被定义为响应式数据。</p><p>通过以上内容的讲解，我们应该知道的是 <code>props</code> 本质上与 <code>data</code> 是相同的，区别就在于二者数据来源不同，其中 <code>data</code> 数据定义的组件自身，我们称其为本地数据，而 <code>props</code> 数据来自于外界。</p><p>另外我们还有一段代码没有讲解，就是 <code>for...in</code> 循环的最后一段代码，如下：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`_props`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>在讲解 <code>data</code> 选项初始化的时候我们见过类似的代码，如下：</p><pre class="language-js"><code><span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`_data`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
</code></pre><p>所以这么做的目的就是在组件实例对象上第一与 <code>props</code> 同名的属性，使得我们能够通过组件实例对象直接访问 <code>props</code> 数据，但其最终代理的值仍然是 <code>vm._props</code> 对象下定义的 <code>props</code> 数据。另外我们要注意这里 <code>if</code> 语句条件：</p><pre class="language-js"><code><span class="highlighted-line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>  <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`_props`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>只有当 <code>key</code> 不在组件实例对象上以及其原型链上有定义时才会进行代理，这是一个针对子组件的优化操作，对于子组件来讲这个代理工作在创建子组件构造函数时就完成了，即在 <code>Vue.extend</code> 函数中完成的，这么做的目的是避免每次创建子组件实例时都会调用 <code>proxy</code> 函数去做代理，由于 <code>proxy</code> 函数中使用了 <code>Object.defineProperty</code> 函数，该函数的性能表现不佳，所以这么做能够提升一定的性能指标。更多这部分的详细信息我们会在后面讲解 <code>Vue.extend</code> 函数及相关子组件创建时间的时候为大家详细说明。</p><p>最后我们再来看一下初始化 <code>props</code> 部分打印警告信息相关的内容，如下：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hyphenatedKey <span class="token operator">=</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReservedAttribute</span><span class="token punctuation">(</span>hyphenatedKey<span class="token punctuation">)</span> <span class="token operator">||</span>
      config<span class="token punctuation">.</span><span class="token function">isReservedAttr</span><span class="token punctuation">(</span>hyphenatedKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token string">`&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hyphenatedKey<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is a reserved attribute and cannot be used as component prop.`</span></span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isUpdatingChildComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token string">`Avoid mutating a prop directly since the value will be `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`overwritten whenever the parent component re-renders. `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`Instead, use a data or computed property based on the prop's `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`value. Prop being mutated: &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;`</span></span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>在非生产环境下会执行 <code>if</code> 语句块的代码，首先执行的如下这段代码：</p><pre class="language-js"><code><span class="token keyword">const</span> hyphenatedKey <span class="token operator">=</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReservedAttribute</span><span class="token punctuation">(</span>hyphenatedKey<span class="token punctuation">)</span> <span class="token operator">||</span>
    config<span class="token punctuation">.</span><span class="token function">isReservedAttr</span><span class="token punctuation">(</span>hyphenatedKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">warn</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token string">`&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hyphenatedKey<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is a reserved attribute and cannot be used as component prop.`</span></span><span class="token punctuation">,</span>
    vm
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>首先使用 <code>hyphenate</code> 将 <code>prop</code> 的名字转为连字符加小写的形式，并将转换后的值赋值给 <code>hyphenatedKey</code> 常量，紧接着又是一个 <code>if</code> 条件语句块，其条件是在判断 <code>prop</code> 的名字是否是保留的属性(<code>attribute</code>)，如果是则会打印警告信息，警告你不能使用保留的属性(<code>attribute</code>)名作为 <code>prop</code> 的名字。</p><p>上面代码中的 <code>hyphenate</code> 和 <code>isReservedAttribute</code> 还是都来自于 <code>src/shared/util.js</code> 文件，可以在附录 <a href="/vue-design/appendix/shared-util.html">shared/util.js 文件工具方法全解</a> 中查看讲解。</p><p>接着使用了 <code>defineReactive</code> 函数定义 <code>props</code> 数据：</p><pre class="language-js"><code><span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isUpdatingChildComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token string">`Avoid mutating a prop directly since the value will be `</span></span> <span class="token operator">+</span>
      <span class="token template-string"><span class="token string">`overwritten whenever the parent component re-renders. `</span></span> <span class="token operator">+</span>
      <span class="token template-string"><span class="token string">`Instead, use a data or computed property based on the prop's `</span></span> <span class="token operator">+</span>
      <span class="token template-string"><span class="token string">`value. Prop being mutated: &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;`</span></span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>可以看到与生产环境不同的是，在调用 <code>defineReactive</code> 函数时多传递了第四个参数，我们知道 <code>defineReactive</code> 函数的第三个参数是 <code>customSetter</code>，即自定义的 <code>setter</code>，这个 <code>setter</code> 会在你尝试修改 <code>props</code> 数据时触发，并打印警告信息提示你不要直接修改 <code>props</code> 数据。</p><h3 id="props-的校验"><a href="#props-的校验" aria-hidden="true" class="header-anchor">#</a> props 的校验</h3><p>在这一小节我们主要聚焦在如下这句代码：</p><pre class="language-js"><code><span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">validateProp</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> propsOptions<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
</code></pre><p>也就是 <code>props</code> 的校验，和一些其他工作，比如获取默认值等。如上这句代码是在 <code>initProps</code> 函数体内的 <code>for...in</code> 循环语句，传递给 <code>validateProp</code> 函数的四个参数分别是：</p><ul><li><code>key</code>：<code>prop</code> 的名字</li><li><code>propsOptions</code>：整个 <code>props</code> 选项对象</li><li><code>propsData</code>：整个 <code>props</code> 数据来源对象</li><li><code>vm</code>：组件实例对象</li></ul><p>假如我们定义了如下组件：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'someComp'</span><span class="token punctuation">,</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    prop1<span class="token punctuation">:</span> String
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>并像如下代码这样使用：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">prop1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>str<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><p>那么 <code>validateProp</code> 函数接收的四个参数将会是：</p><pre class="language-js"><code><span class="token comment">// props 的名字</span>
key <span class="token operator">=</span> <span class="token string">'prop1'</span>
<span class="token comment">// props 选项参数</span>
propOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
  prop1<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> String
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// props 数据</span>
propsData <span class="token operator">=</span> <span class="token punctuation">{</span>
  prop1<span class="token punctuation">:</span> <span class="token string">'str'</span>
<span class="token punctuation">}</span>
<span class="token comment">// 组件实例对象</span>
vm <span class="token operator">=</span> vm
</code></pre><p>了解了 <code>validateProp</code> 函数的参数之后，我们可以开始研究 <code>validateProp</code> 函数内的代码了，在该函数的一开头定义了两个常量和一个变量，如下：</p><pre class="language-js"><code><span class="token keyword">const</span> prop <span class="token operator">=</span> propOptions<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token keyword">const</span> absent <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>propsData<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token keyword">let</span> value <span class="token operator">=</span> propsData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
</code></pre><p>其中常量 <code>prop</code> 的值为 <code>propOptions[key]</code>，也就是名字为 <code>key</code> 的 <code>props</code> 的定义，拿上面的例子来说，如果 <code>key</code> 的值为 <code>prop1</code>，那么常量 <code>prop</code> 的值为：</p><pre class="language-js"><code><span class="token keyword">const</span> prop <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> String
<span class="token punctuation">}</span>
</code></pre><p>第二个常量是 <code>absent</code>，它是一个布尔值，代表着对应的 <code>prop</code> 在 <code>propsData</code> 上是否有数据，或者换句话说外界是否传递了该 <code>prop</code> 给组件。如果 <code>absent</code> 为真，则代表 <code>prop</code> 数据缺失。</p><p>第三个定义的 <code>value</code> 是一个变量，它的值是通过读取 <code>propsData</code> 得到的，当然了如果外界没有向组件传递相应的 <code>prop</code> 数据，那么 <code>value</code> 就是 <code>undefined</code>。</p><p>再往下定义了 <code>booleanIndex</code> 常量：</p><pre class="language-js"><code><span class="token keyword">const</span> booleanIndex <span class="token operator">=</span> <span class="token function">getTypeIndex</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>type<span class="token punctuation">)</span>
</code></pre><p><code>booleanIndex</code> 常量的值是调用 <code>getTypeIndex</code> 函数的返回值，那么 <code>getTypeIndex</code> 函数的作用是什么呢？首先 <code>getTypeIndex</code> 函数接收两个参数，这两个参数都是某一个类型数据结构的构造函数，它可以是 <code>javascript</code> 原生数据类型的构造函数，也可以是自定义构造函数。<code>getTypeIndex</code> 函数的作用准备的说是用来查找第一个参数所指定的类型构造函数是否存在于第二个参数所指定的类型构造函数数组中，没错第二个参数可能是一个数组，比如我们像如下这样定义 <code>props</code>：</p><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  prop1<span class="token punctuation">:</span> <span class="token punctuation">[</span>Number<span class="token punctuation">,</span> String<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>那么经过规范化后 <code>propOptions</code> 将是：</p><pre class="language-js"><code>propOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
  prop1<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> <span class="token punctuation">[</span>Number<span class="token punctuation">,</span> String<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>回过头来，如果 <code>getTypeIndex</code> 函数第一个参数所指定的类型构造函数存在于第二个参数所指定的类型构造函数数组中，那么 <code>getTypeIndex</code> 函数将返回第一个参数在第二个参数数组中的位置，否则返回 <code>-1</code>，这说明第一个参数指定的类型构造函数不在第二个参数指定类型构造函数数组中。最后补充一下，第二个参数可能是数组也可能是单一的一个类型构造函数。</p><p>具体看一下 <code>getTypeIndex</code> 函数的实现，找到 <code>getTypeIndex</code> 函数，它定义在 <code>src/core/util/props.js</code> 文件的最下方，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getTypeIndex</span> <span class="token punctuation">(</span>type<span class="token punctuation">,</span> expectedTypes<span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>expectedTypes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">isSameType</span><span class="token punctuation">(</span>expectedTypes<span class="token punctuation">,</span> type<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> expectedTypes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameType</span><span class="token punctuation">(</span>expectedTypes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> i
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><p>我们可以看到在 <code>getTypeIndex</code> 函数内部首先检测了 <code>expectedTypes</code> 是否为数组，如果不是数组那说明是一个单一的类型构造函数，此时会执行如下高亮的代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>expectedTypes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="highlighted-line">  <span class="token keyword">return</span> <span class="token function">isSameType</span><span class="token punctuation">(</span>expectedTypes<span class="token punctuation">,</span> type<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span></span><span class="token punctuation">}</span>
</code></pre><p>这句代码调用了 <code>isSameType</code> 函数，并将两个类型构造函数作为参数传递，<code>isSameType</code> 函数的作用就是用来判断给定的两个类型构造函数是否相同，找到 <code>isSameType</code> 函数，它定义在 <code>getTypeIndex</code> 函数的上方，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getType</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> match <span class="token operator">=</span> fn <span class="token operator">&amp;&amp;</span> fn<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/^\s*function (\w+)/</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> match <span class="token operator">?</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token string">''</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">isSameType</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">getType</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">getType</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>通过如上代码可知 <code>isSameType</code> 函数是通过调用 <code>getType</code> 函数获取到类型的描述后进行比较的，有的同学可能会问直接将两个类型作比较不就可以了吗？为什么要这么麻烦？实际上这么做肯定是有原因的，我们可以看到在 <code>getType</code> 函数上方有这样一段注释：</p><pre class="language-js"><code><span class="token comment">/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */</span>
</code></pre><p>这是在说简单的类型之间直接比较在不同的 <code>iframes / vms</code> 之间是不管用的，我们回想一下如何判断一个数据是否是数组的方法，其中一个方法就是使用 <code>instanceof</code> 操作符：</p><pre class="language-js"><code>someData <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
</code></pre><p>这种方式的问题就在于，不同 <code>iframes</code> 之间的 <code>Array</code> 构造函数本身都是不相等的。所以以上判断方法只适用于在同一个 <code>iframes</code> 环境下。</p><p>同理，为了做到更严谨的判断，我们需要使用 <code>getType</code> 函数，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getType</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> match <span class="token operator">=</span> fn <span class="token operator">&amp;&amp;</span> fn<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/^\s*function (\w+)/</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> match <span class="token operator">?</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token string">''</span>
<span class="token punctuation">}</span>
</code></pre><p><code>getType</code> 函数很简单，它接收一个函数作为参数，然后使用正则去匹配该函数 <code>toString()</code> 后的字符串，并捕获函数的名字，最后如果捕获成功则返回函数名字，否则返回空字符串。这样一来，在做类型比较的时候本质上是做字符串之间的比较，这样就永远不会有问题。</p><p>我们再回到 <code>isSameType</code> 函数：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isSameType</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">getType</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">getType</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>可知如果两个参数给定的类型构造函数相同则 <code>isSameType</code> 函数返回真，否则返回假。我们再来查看 <code>getTypeIndex</code> 函数：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getTypeIndex</span> <span class="token punctuation">(</span>type<span class="token punctuation">,</span> expectedTypes<span class="token punctuation">)</span><span class="token punctuation">:</span> number <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>expectedTypes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="highlighted-line">    <span class="token keyword">return</span> <span class="token function">isSameType</span><span class="token punctuation">(</span>expectedTypes<span class="token punctuation">,</span> type<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span></span>  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> expectedTypes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameType</span><span class="token punctuation">(</span>expectedTypes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> i
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><p>如果 <code>expectedTypes</code> 不是数组，那么如果传递给 <code>getTypeIndex</code> 函数的两个参数类型相同，则返回数字 <code>0</code>，否则返回数字 <code>-1</code>。</p><p>接着如果 <code>expectedTypes</code> 是一个数组，则通过 <code>for</code> 循环遍历该数组中的每一个类型构造函数，并使用 <code>isSameType</code> 函数让其与给定的类型构造函数做对比，如果二者相同则直接返回给定类型构造函数在 <code>expectedTypes</code> 数组中的位置，如果没有在 <code>expectedTypes</code> 数组中找到给定的类型构造函数则 <code>getTypeIndex</code> 函数最后会返回 <code>-1</code>。</p><p>总之 <code>getTypeIndex</code> 函数的返回值如果大于 <code>-1</code>，则说明给定的类型构造函数在期望的类型构造函数之中。</p><p>再回过头来看这段代码：</p><pre class="language-js"><code><span class="token keyword">const</span> booleanIndex <span class="token operator">=</span> <span class="token function">getTypeIndex</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>type<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>booleanIndex <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>absent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>prop<span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token string">''</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// only cast empty string / same name to boolean if</span>
    <span class="token comment">// boolean has higher priority</span>
    <span class="token keyword">const</span> stringIndex <span class="token operator">=</span> <span class="token function">getTypeIndex</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>type<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stringIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> booleanIndex <span class="token operator">&lt;</span> stringIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      value <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>也就是说常量 <code>booleanIndex</code> 的值如果大于 <code>-1</code>，说明在定义 <code>props</code> 时指定了 <code>Boolean</code> 类型。此时如上代码中 <code>if</code> 语句块的内容将被执行，在 <code>if</code> 语句块内首先检测如下条件：</p><pre class="language-js"><code>absent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>prop<span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">)</span>
</code></pre><p>其中 <code>absent</code> 常量我们前面介绍过，它为真说明外界没有向组件传递该 <code>prop</code>，所以如上条件所代表的意思是：<strong>外界没有为组件传递该 <code>prop</code>，并且该 <code>prop</code> 也没有指定默认值</strong>。在这种情况下如果你指定该 <code>prop</code> 的类型为 <code>Boolean</code>，那么 <code>Vue</code> 会自动将该 <code>prop</code> 的值设置为 <code>false</code>。</p><p>如果 <code>absent</code> 为假，说明外界向组件传递了该 <code>prop</code>，此时会进入 <code>else...if</code> 判断，判断条件如下：</p><pre class="language-js"><code>value <span class="token operator">===</span> <span class="token string">''</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
</code></pre><p>这说明外界向组件传递的 <code>prop</code> 要么是一个空字符串，要么就是一个名字由驼峰转连字符后与值为相同字符串的 <code>prop</code>，如下：</p><pre class="language-html"><code><span class="token comment">&lt;!-- 值为空字符串 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">prop1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 名字由驼峰转连字符后与值为相同字符串 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">someProp</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>some-prop<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><p>如果你想如上代码那样为组件传递 <code>props</code>，并且这些指定了这些 <code>props</code> 的类型包括 <code>Boolean</code> 类型。那么此时 <code>else...if</code> 语句块的代码将被执行，如下：</p><pre class="language-js"><code><span class="token comment">// only cast empty string / same name to boolean if</span>
<span class="token comment">// boolean has higher priority</span>
<span class="token keyword">const</span> stringIndex <span class="token operator">=</span> <span class="token function">getTypeIndex</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>type<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>stringIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> booleanIndex <span class="token operator">&lt;</span> stringIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  value <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre><p>这句代码首先定义了 <code>stringIndex</code> 常量，该常量的值是 <code>String</code> 类型在 <code>prop</code> 类型定义中的位置。接着是一个 <code>if</code> 条件语句，我们看一下判断条件：</p><pre class="language-js"><code>stringIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> booleanIndex <span class="token operator">&lt;</span> stringIndex
</code></pre><p>如果 <code>stringIndex &lt; 0</code> 则说明没有为该 <code>prop</code> 指定 <code>String</code> 类型，否则说明为 <code>prop</code> 指定了 <code>String</code> 类型，但由于之前的判断能够确定的是已经为 <code>prop</code> 指定了 <code>Boolean</code> 类型，那么说明此时至少为该 <code>prop</code> 指定了两种类型：<code>String</code> 和 <code>Boolean</code>。这时会将 <code>booleanIndex</code> 与 <code>stringIndex</code> 作比较，比较的目的是检测 <code>String</code> 和 <code>Boolean</code> 这两个类型谁定义在前面，所以如上条件成立所代表的意思是：</p><ul><li>1、没有定义 <code>String</code> 类型</li><li>2、虽然定义了 <code>String</code> 类型，但是 <code>String</code> 类型的优先级没有 <code>Boolean</code> 高</li></ul><p>这时会将该 <code>prop</code> 的值设置为 <code>true</code>，而非字符串。举个例子：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'someComp'</span><span class="token punctuation">,</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    prop1<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      type<span class="token punctuation">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Boolean<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>上面的代码中我们定义了组件 <code>&lt;some-comp/&gt;</code>，并且定义了一个名字叫做 <code>prop1</code> 的 <code>prop</code>，我们为该 <code>prop</code> 制定了两个类型构造函数 <code>String</code> 和 <code>Boolean</code>，而且 <code>String</code> 的优先级要高于 <code>Boolean</code>，所以此时你如果像如下这样使用该组件：</p><pre class="language-html"><code><span class="token comment">&lt;!-- 值为空字符串 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">prop1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 名字由驼峰转连字符后与值为相同字符串 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">someProp</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>some-prop<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><p>那么该组件接收到的 <code>prop</code> 就会作为普通字符串处理，即 <code>prop1</code> 的值就是空字符串或字符串 <code>'some-prop'</code>。</p><p>如果我们调换一下 <code>prop1</code> 的类型构造函数的顺序，如下：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'someComp'</span><span class="token punctuation">,</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    prop1<span class="token punctuation">:</span> <span class="token punctuation">{</span>
<span class="highlighted-line">      type<span class="token punctuation">:</span> <span class="token punctuation">[</span>Boolean<span class="token punctuation">,</span> String<span class="token punctuation">]</span></span>    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>我们先定义了 <code>Boolean</code> 类型，如果此时你依然像如下这样使用组件：</p><pre class="language-html"><code><span class="token comment">&lt;!-- 值为空字符串 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">prop1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 名字由驼峰转连字符后与值为相同字符串 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">someProp</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>some-prop<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><p>那么 <code>prop1</code> 的值将会是布尔类型 <code>true</code>。最后补充一点，实际上如下两种使用 <code>props</code> 的方式是等价的：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">prop1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!-- 等价于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>some-comp</span> <span class="token attr-name">prop1</span> <span class="token punctuation">/&gt;</span></span>
</code></pre><p>最后我们再来回顾一下 <code>validateProp</code> 函数中的这段代码：</p><pre class="language-js"><code><span class="token keyword">const</span> booleanIndex <span class="token operator">=</span> <span class="token function">getTypeIndex</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>type<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>booleanIndex <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>absent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>prop<span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token string">''</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token function">hyphenate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// only cast empty string / same name to boolean if</span>
    <span class="token comment">// boolean has higher priority</span>
    <span class="token keyword">const</span> stringIndex <span class="token operator">=</span> <span class="token function">getTypeIndex</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>type<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stringIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> booleanIndex <span class="token operator">&lt;</span> stringIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      value <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>现在我们知道了这段代码的作用实际上对 <code>prop</code> 的类型为布尔值时的特殊处理。接下来我们继续查看 <code>validateProp</code> 函数的后续代码，如下：</p><pre class="language-js"><code><span class="token comment">// check default value</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  value <span class="token operator">=</span> <span class="token function">getPropDefaultValue</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token comment">// since the default value is a fresh copy,</span>
  <span class="token comment">// make sure to observe it.</span>
  <span class="token keyword">const</span> prevShouldObserve <span class="token operator">=</span> shouldObserve
  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token function">toggleObserving</span><span class="token punctuation">(</span>prevShouldObserve<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>这段代码用来检测该 <code>prop</code> 的值是否是 <code>undefined</code>，我们知道 <code>prop</code> 是可以指定默认值的，当外界没有为组件传递该 <code>prop</code> 时，则取默认值作为该 <code>prop</code> 的数据。根据如上代码可知获取默认值的操作由 <code>getPropDefaultValue</code> 函数来完成，并将获取到的默认值重新赋值给 <code>value</code> 变量，获取完默认值之后我们可以看到如下这段代码：</p><pre class="language-js"><code><span class="token keyword">const</span> prevShouldObserve <span class="token operator">=</span> shouldObserve
<span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token function">toggleObserving</span><span class="token punctuation">(</span>prevShouldObserve<span class="token punctuation">)</span>
</code></pre><p>有这段代码首先使用 <code>prevShouldObserve</code> 常量保存了之前的 <code>shouldObserve</code> 状态，紧接着将开关开启，是的 <code>observe</code> 函数能够将 <code>value</code> 定义为响应式数据，最后又还原了 <code>shouldObserve</code> 的状态。之所以这么做是因为取到的默认值是非响应式的，我们需要将其重新定义为响应式数据。</p><p>接着我们再回头看一下 <code>getPropDefaultValue</code> 函数是如何获取默认值的，<code>getPropDefaultValue</code> 函数定义在 <code>validateProp</code> 函数的下方，如下是 <code>getPropDefaultValue</code> 函数的签名：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getPropDefaultValue</span> <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> <span class="token operator">?</span>Component<span class="token punctuation">,</span> prop<span class="token punctuation">:</span> PropOptions<span class="token punctuation">,</span> key<span class="token punctuation">:</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span> any <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p><code>getPropDefaultValue</code> 函数接收三个参数，分别是组件实例对象 <code>vm</code>、<code>prop</code> 的定义对象，以及 <code>prop</code> 的名字 <code>key</code>。在 <code>getPropDefaultValue</code> 函数体内，首先是这样一段代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>prop<span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> undefined
<span class="token punctuation">}</span>
<span class="token keyword">const</span> def <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token keyword">default</span>
</code></pre><p>我们知道在定义 <code>prop</code> 时可以在对象中使用 <code>default</code> 属性指定默认值，所以如上代码用来检测开发者在定义 <code>prop</code> 时是否指定了默认值，如果没有指定默认值则直接返回 <code>undefined</code>。另外如果开发者指定了默认值则定义 <code>def</code> 常量，用来保存默认值。</p><p>再往下是这样一段代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isObject</span><span class="token punctuation">(</span>def<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">warn</span><span class="token punctuation">(</span>
    <span class="token string">'Invalid default value for prop &quot;'</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">'&quot;: '</span> <span class="token operator">+</span>
    <span class="token string">'Props with type Object/Array must use a factory function '</span> <span class="token operator">+</span>
    <span class="token string">'to return the default value.'</span><span class="token punctuation">,</span>
    vm
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>在非生产环境下，如果你的 <code>prop</code> 默认值是对象类型，那么则会打印警告信息，告诉你需要用一个工厂函数返回这个对象类型的默认值，比如：</p><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  prop1<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
      a<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  prop2<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>如上代码定义了两个 <code>prop</code>，其中 <code>prop1</code> 的默认值是一个对象，<code>prop2</code> 的默认值是一个数组，这两个 <code>prop</code> 都是不合法的，你需要用工程函数将默认值返回，如下：</p><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  prop1<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        a<span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  prop2<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这么做的目的是防止多个组件实例共享一份数据所造成的问题。</p><p>再往下是这样一段代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>vm <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData <span class="token operator">&amp;&amp;</span>
  vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> undefined <span class="token operator">&amp;&amp;</span>
  vm<span class="token punctuation">.</span>_props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> undefined
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> vm<span class="token punctuation">.</span>_props<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>我们现在还没有讲解创建子组件与根组件的区别，或许大家看到这段代码会有些疑惑。比如上面的 <code>if</code> 条件语句中有这样一个条件：</p><pre class="language-js"><code>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> undefined
</code></pre><p>大家别忘了我们目前讲解的代码是 <code>getPropDefaultValue</code> 函数中的代码，代码既然已经执行到了 <code>getPropDefaultValue</code> 函数那么说明外界没有向组件传递该 <code>prop</code> 数据，那也就是说 <code>vm.$options.propsData[key]</code> 很显然的应该是 <code>undefined</code>。为什么还需要如上判断呢？实际上事情并非像我们想象的那样。这是因为<strong>组件第一次创建与后续的更新走的是两套不太一致的逻辑</strong>。为了证明这一点，我们需要打开 <code>src/core/instance/lifecycle.js</code> 文件找到 <code>updateChildComponent</code> 函数，大家现在只需要知道组件的更新是由 <code>updateChildComponent</code> 函数来完成的即可，在 <code>updateChildComponent</code> 函数内有这样一段代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>propsData <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>_props
  <span class="token keyword">const</span> propKeys <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_propKeys <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> propKeys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> propKeys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">const</span> propOptions<span class="token punctuation">:</span> any <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props <span class="token comment">// wtf flow?</span>
<span class="highlighted-line">    props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">validateProp</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> propOptions<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> vm<span class="token punctuation">)</span></span>  <span class="token punctuation">}</span>
  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token comment">// keep a copy of raw propsData</span>
  vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData <span class="token operator">=</span> propsData
<span class="token punctuation">}</span>
</code></pre><p>注意如上高亮的那句代码，这句代码同样调用 <code>validateProp</code> 函数，所以 <code>getPropDefaultValue</code> 函数的如下代码完全是为组件更新时准备的：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>vm <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData <span class="token operator">&amp;&amp;</span>
  vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> undefined <span class="token operator">&amp;&amp;</span>
  vm<span class="token punctuation">.</span>_props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> undefined
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> vm<span class="token punctuation">.</span>_props<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>当执行 <code>updateChildComponent</code> 函数更新组件时，在调用 <code>validateProp</code> 函数之前 <code>vm.$options.propsData</code> 还没有被更新，注意如下高亮代码：</p><pre class="language-js"><code><span class="token comment">// updateChildComponent 函数</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>propsData <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>_props
  <span class="token keyword">const</span> propKeys <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_propKeys <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> propKeys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> propKeys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">const</span> propOptions<span class="token punctuation">:</span> any <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props <span class="token comment">// wtf flow?</span>
    props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">validateProp</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> propOptions<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token comment">// keep a copy of raw propsData</span>
<span class="highlighted-line">  vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData <span class="token operator">=</span> propsData</span><span class="token punctuation">}</span>
</code></pre><p>可以看到 <code>vm.$options.propsData</code> 的更新是在调用 <code>validateProp</code> 之后进行的，所以当组件更新时如下代码中的 <code>vm.$options.propsData</code> 是上一次组件更新或创建时的数据：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>vm <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData <span class="token operator">&amp;&amp;</span>
  vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> undefined <span class="token operator">&amp;&amp;</span>
  vm<span class="token punctuation">.</span>_props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> undefined
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> vm<span class="token punctuation">.</span>_props<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>明白了这些我们再来重新审视一下这些判断条件，其中条件 <code>vm.$options.propsData[key] === undefined</code> 说明上一次组件更新或创建时外界就没有向组件传递该 <code>prop</code> 数据，条件 <code>vm._props[key] !== undefined</code> 说明该 <code>prop</code> 存在非未定义的默认值，又由于上面这段代码存在于 <code>getPropDefaultValue</code> 函数中，所以如上 <code>if</code> 条件成立则说明：</p><ul><li>1、当前组件处于更新状态，且没有传递该 <code>prop</code> 数据给组件</li><li>2、上一次更新或创建时外界也没有向组件传递该 <code>prop</code> 数据</li><li>3、上一次组件更新或创建时该 <code>prop</code> 拥有一个不为 <code>undefined</code> 的默认值</li></ul><p>那么此时应该返回之前的 <code>prop</code> 值(即默认值)作为本次渲染该 <code>prop</code> 的默认值。这样就能避免触发没有意义的响应。为什么能避免触发无意义的响应呢？很简单，假设每次都重新获取默认值而不是返回之前的默认值，那么如下 <code>prop</code> 的默认值将总是会变化的：</p><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  prop1<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>由于 <code>prop1</code> 的默认值是由工厂函数返回的对象，这个对象每次都是不同的，即使看上去数据是一样的，但他们具有不同的引用，这样每次都会触发响应，但试图并没有任何变化，也就是说触发了没有意义的响应。而解决办法就是前面所介绍的，返回上一次的默认值就可以了。</p><p>最后我们再来看 <code>getPropDefaultValue</code> 函数中的最后一段代码：</p><pre class="language-js"><code><span class="token keyword">return</span> <span class="token keyword">typeof</span> def <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getType</span><span class="token punctuation">(</span>prop<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">'Function'</span>
  <span class="token operator">?</span> def<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">:</span> def
</code></pre><p>我们知道 <code>def</code> 常量为该 <code>prop</code> 的 <code>default</code> 属性的值，它代表了默认值，但是由于默认值可能是由工厂函数执行产生的，所以如果 <code>def</code> 的类型是函数值通过执行 <code>def.call(vm)</code> 来获取默认值，否则直接使用 <code>def</code> 作为默认值。当然了我们还需要一个判断条件，即：</p><pre class="language-js"><code><span class="token function">getType</span><span class="token punctuation">(</span>prop<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">'Function'</span>
</code></pre><p>这说明我们指定了该 <code>prop</code> 的默认值类型为函数类型，所以此时我们就不应该通过执行 <code>def</code> 函数来获取默认值了，应该直接将 <code>def</code> 函数本身作为默认值看待，因为该 <code>prop</code> 所期望的值就是一个函数。</p><h2 id="methods-选项的初始化及实现"><a href="#methods-选项的初始化及实现" aria-hidden="true" class="header-anchor">#</a> methods 选项的初始化及实现</h2><h2 id="provide-选项的初始化及实现"><a href="#provide-选项的初始化及实现" aria-hidden="true" class="header-anchor">#</a> provide 选项的初始化及实现</h2><h2 id="inject-选项的初始化及实现"><a href="#inject-选项的初始化及实现" aria-hidden="true" class="header-anchor">#</a> inject 选项的初始化及实现</h2></div><div class="content edit-link"><a href="https://github.com/HcySunYang/vue-design/edit/master/docs/art/9vue-state-init.md" target="_blank" rel="noopener noreferrer">错别字纠正</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/vue-design/art/8vue-reactive-dep-watch.html" class="prev">
          渲染函数的观察者与进阶的数据响应系统
        </a></span><span class="next"><a href="/vue-design/art/80vue-compiler-start.html">
          Vue 的编译器初探
        </a> →
      </span></p></div></div></div></div>
    <script src="/vue-design/assets/js/5.cae9faa7.js" defer></script><script src="/vue-design/assets/js/app.6d653ceb.js" defer></script>
  </body>
</html>
